---
title: "[F-Lab 모각코 챌린지] 46일차"
excerpt: "five lines of code - 2"
categories:
  - Javascript
tags:
  - f-lab
  - 에프랩
  - TIL
  - Typescript
  - Five lines of code
last_modified_at: 2023-07-04
toc: true
---

이어서 파이브 라인스 오브 코드 2장을 요약해 본다.

# 리팩터링 깊게 들여다보기

이번장에서는 리팩터링이 무엇인지, 왜 기술적 관점에서 중요한지 알아보자.

## 가독성 및 유지보수성 향상

더 나은 코드를 만드는 것과 코드가 하는 일을 변경하지 않는다는 두 가지 내용을 살펴보겠다.

### 코드 개선

#### 가독성

가독성이 좋은 코드는 의도를 전달한다. 즉 가독성이 좋으면 코드가 무슨 일을 하는지 알기 쉽다는 뜻이다. 코딩 컨벤션, 주석, 변수명 등이 방법으로 사용되지만, 항상 의도를 잘 전달하진 않는다. 아래의 코드를 보자.

```javascript
function checkValue(str: boolean) {
  // 값 체크
  if (str !== false) {
    // 반환
    return false;
  } else; // 그렇지 않으면
  return str;
}
```

의미가 불분명한 메소드명과 타입 지정(타입은 boolean인데 매개변수명은 str)을 사용한다. 주석은 메서드 명을 반복하거나 의미가 없다. 이중 부정은 읽기 어렵다. 세미 콜론이 문맥을 읽는데 방해된다. 리턴으로 한 번은 false를, 한 번은 매개변수명을 리턴해 혼란스럽게 한다.

극단적이지만 잘못된 예를 알기 쉬운 예제이다. 사실 다음과 같은 코드면 충분하고 더 읽기 쉽다.

```javascript
function isTrue(bool: boolean) {
  if (bool) return true;
  else return false;
}

// 혹은
function isTrue(bool: boolean) {
  return bool;
}
```

#### 유지보수성

코드를 수정해야할 때 수정해야 할 위치를 먼저 찾는다. 유지보수성은 얼마나 많은 위치를 조사해야 하는지를 나타내는 표현이다. 이게 오래 걸리면 유지보수성이 나쁘다고 할 수 있다.

어떤 시스템에서 무언가를 수정했는데 다른 곳에서 문제가 발생한다면, 그런 시스템을 취약하다고 한다. 이 취약성의 근원은 일반적으로 전역상태(global state)이다.

전역 상태의 문제는 내부 변수에 외부의 데이터를 할당하는 경우가 많다는 것인데, 이는 실수로 데이터가 손상될 가능성이 있다는 것이다. 코드에서 이 상태를 명시적으로 확인하지 않는 속성을 불변속성이라고 한다. "이 값은 음수일 수 없어" 같은 가정으로 말이다. 하지만 사람이나 상황이 바뀌며(그렇지 않더라도 시간이 지나 까먹어서) 불변속성이 끝까지 유효할 가능성은 거의 없다.

변수를 명시적으로 체크해 불변속성을 제거함으로 유지보수성을 향상시킬 수 있다. 하지만 이렇게 하면 리팩터링에서 해서는 안되는, 코드가 수행하는 작업이 변경된다. 대신 불변속성을 더욱 쉽게 볼 수 있도록 서로 가깝게 이동시켜 유지보수성을 향상시킬 수 있다. 이것을 불변속성의 범위제한이라고 한다.

### 코드가 하는 일은 바꾸지 않고 유지보수하기

값을 입력하면 리팩터링 전후의 결과가 동일해야한다.

하지만 성능이 바뀔 수는 있다. 리팩터링 중에는 코드가 느려져도 거의 신경쓰지 않는다. 다음과 같은 이유 때문이다.

1. 대부분의 시스템에서 성능은 가독성과 유지보수성보다 가치가 떨어진다.
2. 성능이 중요한 경우 프로파일링 도구나 성능 전문가의 지도를 받아 리펙터링과 다른 단계에서 처리해야 한다.

리팩터링을 할 때는 협업을 생각해 적절한 범위를 결정해야한다.

지금까지 말한 리팩터링의 핵심을 요약하자면,

1. 의도를 전달함으로써 가독성 향상
2. 불변속성의 범위 제한을 통한 유지보수성 향상
3. 범위 밖의 코드에 영향을 주지 않고 1, 2를 수행

## 속도, 유연성 및 안정성 확보

좋은 코드베이스에서 작업하면 더 생산적이고 실수를 적게할 수 있다.

코드이 품질에 가장 큰 영향을 미치는 것은 아키텍쳐 패턴이다.

### 상속보다는 컴포지션 사용

범위가 제한되지 않은 불변속성은 유지보수하기 어렵다. 일반적인 상속은 이를 야기할 수 있어 컴포지션을 사용하는 게 낫다. 이것이 이 책의 핵심이다. 앞으로 살펴볼 대부분의 리팩터링 패턴과 규칙은 구체적으로 객체 컴포지션을 돕기 위한 것들이다. 즉, 객체가 내부에 다른 객체의 참조를 갖는 것이다. 아래의 새(Bird)에 대한 코드로 살펴보자.

```typescript
interface Bird {
  hasBeak(): boolean;
  canfly(): boolean;
}

class CommonBird implements Bird {
  hasBeak() {
    return true;
  }

  canfly() {
    return true;
  }
}

class Penguin extends CommonBird {
  canfly() {
    return false;
  }
}
```

```typescript
interface Bird {
  hasBeak(): boolean;
  canfly(): boolean;
}

class CommonBird implements Bird {
  hasBeak() {
    return true;
  }

  canfly() {
    return true;
  }
}

class Penguin implements Bird {
  private bird = new CommonBird(); // 컴포지션
  hasBeak() {
    return bird.hasBeak(); // 호출을 직접 명시적으로 전달해야 함함
  }
  canFly() {
    return false;
  }
}
```

이 책에서는 아래 코드가 더 좋다고 본다. 여기에 `canSwim`이란 메서드가 `Bird`에 추가된다면 두 예시 모두 `CommonBird`에 `canSwim`이 추가될 것이다.

```typescript
class CommonBird implements Bird {
  // ...
  canSwim() {
    return false;
  }
}
```

컴포지션을 사용한 예에서는 `Penguin`이 `canSwim`을 구현하지 않아 컴파일 오류가 발생한다. 따라서 이를 인지하고 수동으로 메서드를 추가할 수 있다. 사람으 기억력에 의존할 필요가 없다.

#### 유연성

컴포지션을 중심으로 만들어진 시스템은 레고 블록을 가지고 노는 것과 같다. 새로운 것을 만드는 것이 놀라울 정도로 빠르다.

### 수정이 아니라 추가로 코드 변경

컴포지션의 가장 큰 장점은 추가로 변경이 가능하다는 것이다. 이것은 기존 기능이나 코드에 영향을 주지 않고 변경이 가능하다는 의미다. 이 책 전체에서 이것이 기술적으로 어떻게 가능한지 설명한다. 이 속성은 개방 폐쇄 원칙이라고 한다.

#### 프로그래밍 속도

무언가 변경할 때 가장 먼저 하는 일 중 하나는 아무것도 손상시키지 않는 것이다. 이때 다른 코드를 건들잊 않고 변경할 수 있다면 모든 시간을 아낄 수 있다. 물론 코드베이스가 늘어나는 것은 문제가 되므로 사용하지 않는 코드는 빠르게 삭제해야 한다.

#### 안정성

추가에 의한 변경 방식을 따르면 기존 코드를 항상 보존할 수 있다. 새 코드가 실패하면 이전 기능으로 대체하는 것은 쉽다.

## 리팩터링과 일상 업무

리팩터링은 프로그래머의 일상 업무가 돼야 한다. 코드를 리팩터링하지 않고 전달한다면 다른 프로그래머의 시간을 빼앗는 셈이다. 나아가 기술 부채가 쌓인다.

- 레거시 시스템에서는 코드를 변경하기 전 먼저 리팩터링 해라.
- 변경 이후에도 리팩터링 해라.

### 학습 방법으로서의 리팩터링

리팩터링은 배우는 데 시간이 걸리지만, 결국 익숙해진다. 이는 나아가 코드를 작성하고 생각하는 방식을 바꾼다. 안정성이 확보되면 이 안정성을 어떻게 활용할 수 있을지 생각하기 시작한다.

## 소프트웨어 분야에서 '도메인' 정의하기

기술적인 면이 어떻든, 소프트웨어는 실생활의 특정 측면을 모델링한 것이다. 이 실제 세계의 구성요소를 도메인이라고 한다.

소프트웨어 개발을 할 때 때때로 도메인 전문가조차도 낯선 새로운 코너케이스를 찾아야 한다. 결과적으로 프로그래밍은 주로 학습과 의사소통에 관한 것이다.
