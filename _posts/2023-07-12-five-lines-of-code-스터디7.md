---
title: "[F-Lab 모각코 챌린지] 54일차"
excerpt: "five lines of code - 7"
categories:
  - Refactoring
tags:
  - f-lab
  - 에프랩
  - TIL
  - Typescript
  - Five lines of code
last_modified_at: 2023-07-12
toc: true
---

다시 파이브라인스 오브 코드다. 계속해서 규칙들을 배워보자.

# 타입 코드 처리하기

## 긴 if문의 리팩터링

### 규칙: `switch` 문을 사용하지 말 것

#### 정의

`default` 케이스가 없고 모든 `case`에 반환 값이 있는 경우가 아니라면, `switch`문을 사용하지 마라.

#### 설명

`switch`문은 편의성 때문에 버그가 생길 수 있다. 두 가지 문제가 생길 만한 부분이 있다.

첫 번째는 `default`다. `switch` 문을 사용하는 경우 무엇을 처리할지와 무엇을 처리하지 않을지는 불변속성이다. 그리고 `default`는 모든 값에 대한 처리를 할 필요를 없게 해준다. 이로 인해 변경이 일어날 때 불변속성이 여전히 유효한지 컴파일러를 통해 판단할 수 없게 된다.

두 번째는 `break`다. `break`를 만나기 전까지 `case`를 연속해서 실행하는 fall through 로직이 위험 요소를 만든다.

일반적으로 `switch`를 쓰지 않는 게 좋지만, 정의 부분에 쓰인 것처럼 `default`를 쓰지 않고, 모든 케이스에 `return`을 지정한다는 전제하에 쓸 수 있다.

```typescript
// assertExhausted 트릭
function assertExhausted(x: never): never {
  throw new Error("Unexpected object: " + x);
}

// ...
switch (t) {
  case ...: return ...;
  // ...
  default: assertExhausted(t);
}
```

이런 유형의 함수는 컴파일러가 모든 값을 매핑했는지 확인할 수 있게 할 경우 다섯 중 제한에 맞게 변환할 수 없는 몇 안되는 함수중 하나이다.

#### 스멜

리팩토링에서 `switch`는 스멜의 이름이다. `switch`는 컨텍스트, 즉 값 x를 처리하는 방법에 초점을 맞춘다. 이것은 데이터에서 불변속성을 더 멀리 위치시켜 불변속성을 전역화하는 것을 의미한다.

### 규칙: 인터페이스에서만 상속 받을 것

#### 정의

상속은 오직 인터페이스를 통해서만 받는다.

#### 설명

클래스나 추상 클래스에서 상속을 받으면 안된다. 보통 추상 클래스를 사용하는 이유는 일부 메서드는 기본 구현을 제공하고 나머지 메서드는 추상화함으로써 중복을 줄이고 코드의 줄을 줄이기 위함이다.

하지만 단점이 훨씬 더 많다. 코드 공유는 커플링(결합)을 유발한다. 이 경우 추상 클래스의 코드가 그렇다.

기본 구현된 메서드가 있는 경우, 일부 하위 클래스에서 메서드를 재정의해야 할 때, 기본 구현이 있기 때문에 컴파일러를 통해 재정의가 필요한 메서드인지 잡아낼 수가 없다.

#### 스멜

언젠가 얘기했던 상속보다는 컴포지션이 더 좋다는 원칙에서 도출된 규칙이다.

#### 의도

상속을 받기 위해 다른 객체를 참조함으로써 코드를 공유해야 한다.

#### 참조

이 규칙은 Gof의 디자인 패턴 이라는 책에서 나온다.
