---
title: "[66해빗 페이백 챌린지] 5일차"
excerpt: "가비지 컬렉션"
categories:
  - Javascript
tags:
  - f-lab
  - 에프랩
  - TIL
  - Browser
  - Javascript
  - Garbage Collection
last_modified_at: 2023-05-24
toc: true
---

오늘 공부할 건 메모리 관리 기법 중 가장 유명한 가비지 컬렉션. 자바스크립트의 가비지 컬렉션을 V8 기준으로 알아보자.

# 마크 앤 스윕

웹 폰트가 성능에 영향을 미치는 방식은 크게 두 가지가 있다.

현재 모든 브라우저가 가비지 컬렉팅 알고리즘(정확히는 메이저 가비지 컬렉팅)으로 채택한 놈. 참조 카운팅 알고리즘의 한계점인 순환 참조를 해결할 수 있는 방법으로, ‘닿을 수 없는 메모리’를 정리해야 할 대상으로 여긴다.

root(전역 범위)부터 시작해서 root에서 참조되는 객체1 → 객체1에서 참조되는 객체2 → … 로 향하면서 마킹을 하고, 마킹되지 않은, 즉 닿을 수 없는 객체들을 정리한다. 또한 실행 컨텍스트가 소멸하는 순간 접근이 불가능하게 되기 때문에 순환 참조도 일어나지 않는다.

# 힙의 구조

힙은 세부적으로 여러 구조로 나뉘지만 가비지 컬렉터가 관여하는 부분은 두 부분으로, **old space**와 **new space**가 있다. 두 부분으로 나뉜 이유는 제너레이셔널 가설인가 그거 때문인데, 대부분의 경우 비교적 새로 할당된 객체가 쓸모 없어질 확률이 높다는 것이 가설의 내용이고, 그것에 착안해 모든 객체를 검사하기보단 새로운 객체들을 먼저 잘게 검사해 정리하고, 그 이후 남은 오래된 객체들을 검사하는 게 더 효율적이라는 이유 때문이다.

# 마이너 가비지 컬렉팅(Scavenger)

new space는 작은 크기의 semi space 두 개(from space, to space)로 이루어져 있고 마이너 가비지 컬렉터(scavenger)가 관리한다. 새로운 객체는 from space 에만 저장되다가

1. from space가 꽉 차서 새로운 객체가 들어올 수 없게 되면 마이너 가비지 컬렉팅이 일어난다.
2. from space에 있는 객체 그래프를 따라가며 사용되는 객체(와 그 객체가 참조하는 객체)들을 판별해 to space로 옮겨진다.(메모리 단편화도 줄인댄다. 나중에 알아보자)
3. 여기서 to space로 옮겨지지 못하고 from space에 남은 객체들이 가비지가 되어 정리된다.
4. to space에 있는 객체들이 다시 from space로 이동되고 to space는 비워진다.
5. 또 한번 from space가 가득 차 마이너 가비지 컬렉팅이 일어나서 두 번이나 검사를 받고 살아남은 객체들은 이제 old space로 이동하게 된다.

# 메이저 가비지 컬렉팅(Full Mark-Compact)

old space는 메이저 가비지 컬렉터가 담당한다. new space에서 old space로 객체를 옮길 때 메모리가 부족하면 실행된다. 정확히는 Mark-Sweep-Compact 알고리즘과 Tri-color 알고리즘을 사용한다고 한다. 일단은 그 흐름을 이해하자. 위에서 간단히 설명했지만 순서를 따라가며 좀 더 자세히 알아보자.

## 마킹

어떤 객체가 정리해야 할 대상인지 알아내는 작업. Roots라는 실행 스택과 전역 객체를 담고 있는 객체의 set부터 시작해서 객체들을 [dfs](https://gmlwjd9405.github.io/2018/08/14/algorithm-dfs.html)(Depth-First Search, 깊이 우선 탐색)로 순회하며 Tri-color(white, gray, black)로 마킹한다.

- white: GC가 아직 탐색하지 못한 상태
- gray: 탐색은 했으나, 해당 객체가 참조하고 있는 객체가 있는지 없는지 확인을 안한 상태
- black: 해당 객체가 참조하고 있는 객체까지 확인을 한 상태

1. 일단 모든 객체를 흰색으로 마킹
2. roots 객체를 회색으로 마킹 후 [덱](https://optimuslee.tistory.com/31)에 push_front
3. 덱에서 pop_front 해서 객체 꺼냄
4. 꺼낸 객체는 검정색으로 마킹
5. 꺼낸 객체가 참조하는 객체(들)을 판별
   1. 흰색이면 회색으로 마킹 후 덱에 push_front
   2. 회색이나 검정색이면(여러 객체에서 참조하는 객체의 경우 이미 마킹 되어 있을 수 있음) 무시
6. 덱에서 더 이상 꺼낼 수 없을 때까지 반복
7. 최종적으로 검정색 혹은 흰색 객체만 남음

## 스위핑

흰 색인 객체들의 주소값을 free-list 라는 자료구조에 추가. 이제 이 주소값의 메모리 공간은 사용 가능.

## 압축

메모리 단편화가 심한 곳을 재배치해 추가적인 메모리 확보

\*mark-sweep 알고리즘의 이해를 돕는 그림
![mark-sweep](https://i.imgur.com/rcjSZ0T.gif)

# Orinoco

이 가비지 콜렉팅을 하느라 메인 쓰레드가 다른 일을 못해서 프로그램이 멈추는 현상을 stop-the-world 라 한다. stop-the-world 시간이 길어져 렌더링이 안되고, 버벅이고 그러면 사용자 경험이 저해되니, V8에선 이런 고민에 대한 여러 해결책을 담은 가비지 컬렉팅 프로젝트를 Orinoco라 이름 짓고, V8의 가비지 컬렉터의 이름 또한 그것을 이어 받았다. 어떤 방법으로 stop-the-world 시간을 줄이는지 막는지 알아보자.

## Perallel(병렬적 방식)

이전에는 메인 스레드 혼자 하던 가비지 컬렉팅을 헬퍼 스레드가 함께 처리한다. 스레드간의 동기화를 위해 오버헤드가 발생하지만 stop-the-world 시간은 크게 감소한다.

![Perallel](https://fe-developers.kakaoent.com/static/4200a624d50ee69882d7b48059a7f63c/f058b/orinoco_parallel.png)

## Incremental(점진적 방식)

메인 쓰레드 혼자 적은 양의 작업을 간헐적으로 처리한다. 메인 스레드에서 가비지 컬렉션에 소요하는 시간이 분산돼 좋은 UX를 제공할 수 있다.
![Incremental](https://fe-developers.kakaoent.com/static/b236505ff88452c5dd47c916587f834e/f058b/orinoco_incremental.png)

## Concurrent(동시적 방식)

메인 쓰레드는 가비지 컬렉션을 하지 않고, 헬퍼 쓰레드들이 수행한다. 가비지 콜렉팅 도중 힙의 상태가 바뀔 수 있어 기술적으로 구현하기는 어렵지만, 메인 쓰레드의 stop-the-wolrd 시간이 전혀 없다는 큰 장점이 있다.

![Concurrent](https://fe-developers.kakaoent.com/static/df56bbc5d304db3b6d952431000c459c/f058b/orinoco_concurrent.png)

## 어디에 어떤 방식이 쓰일까?

마이너 가비지 컬렉팅에서 병렬적 방식이 사용된다.

![](https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@main/assets/images/javascript/memory-management-in-v8/minor-gc-uses-parallel.png)

메이저 가비지 컬렝팅은 동시적 마킹으로 시작된다. 메인 쓰레드는 마킹에 관여하지 않고 헬퍼 쓰레드들이 마킹을 하는 것이다. 마킹 작업중에 새로운 객체나 참조가 생성되면 write barrier를 써서 구분한다.

헬퍼 쓰레드의 마킹이 완료되면 메인 쓰레드가 roots에서 부터 닿을 수 있는 객체들이 마킹 되었는지 확인하는 빠른 마킹 단계를 수행한다. 그 이후 헬퍼 쓰레드들과 함께 병렬 압축을 한다. 압축이 안되는 페이지는 스윕 작업을 한다.

![](https://v8.dev/_img/trash-talk/09.svg)

## 언제 가비지 컬렉팅이 실행될까?

위의 방법을 사용한다고 해도 아무때나 가비지 컬렉팅을 하느라 메인 쓰레드가 점유되면 갑자기 스크롤이 버벅댄다거나 애니메이션이 끊겨 보인다거나 할 수도 있다. 그럼 브라우저는 언제 가비지 컬렉팅을 실행할까?

**Idle 상태:** 일반적으로 브라우저는 60fps를 지원한다. 그래서 한 프레임은 대략 16.6ms가 된다. 이 때 모든 작업을 16.6ms 안에 끝내 <u>다음 프레임까지 할 일이 없는 상태</u>를 Idle 상태라고 한다.

그런데 Idle 상태에서도 할 게 있다. Idle 상태에서 다음 프레임까지 해야 할 작업을 Idle task라고 하는데 가비지 컬렉팅이 이 Idle task에 해당된다. Idle task는 다음 프레임 전까지 끝내야 하는 작업이기 때문에 데드라인이 존재하는데, 이 때문에 데드라인에 맞출 수 있는 가비지 컬렉팅을 선택하여 실행하게 된다. 선택지는 총 4개로, 다음과 같다.

1. Scavenge

   new space는 비교적 작은 크기이기에 빠른 속도로 가비지 컬렉팅 할 수 있다.(대체적으로 1ms 이내라고 한다.)

2. Concurrent Mark

   Heap 용량의 한계에 다다르면 위에서 설명한 메이저 가비지 컬렉팅의 마킹을 진행한다. 다만 한 번에 root부터 모든 객체의 참조 관계를 파악하려고 하면 비지니스 로직이 실행되는 메인 스레드가 멈출 수 있기 때문에 마킹 작업은 여러 번에 걸쳐 점진적으로 실행한다. 이 경우 각각의 마킹 작업이 5ms 이하로 처리될 수 있다.

3. Full GC

   다음 프레임까지 남은 시간이 넉넉하고 old space가 가득 차 있으면 마이너 가비지 컬렉팅과 메이저 가비지 컬렉팅 모두를 실행한다. 이 경우 살아있는 객체 수 \* 개별 Marking 속도로 시간을 예측한다는데 무슨 소린지 잘 모르겠다.

4. Full GC + Compaction

   긴 시간동안 Idle 상태일 때 Full GC와 메모리 단편화를 줄이는 작업을 한다.
