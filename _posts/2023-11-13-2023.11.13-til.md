---
title: "2023.11.13 til"
excerpt: "오늘 배운 모든 내용"
categories:
  - til
tags:
  - javascript
last_modified_at: 2023-11-13
toc: true
---

# fetch 함수 살펴보기

서버로 request를 보내고 response를 받는 함수이다.

```javascript
fetch("https://www.google.com")
  .then((response) => response.text())
  .then((result) => {
    console.log(result);
  });
```

첫 번째 `then` 함수를 살펴보자. 나중에 promise를 배울테지만 지금 봐야 할 것은 이 `then` 함수가 `fetch`함수와 동시에 실행된 것이 아니라, 이후에 실행된다는 것이다.  
이 promise의 `then`함수가 `response`가 온 이후 동작하는 콜백을 등록하는 메서드이다. 두 번째 `then`도 마찬가지 이다. 앞선 `then`이 결과를 반환한 이후에 그 결과를 받아서 실행하는 콜백이 등록된다.

정리하자면,

1. fetch 함수는 어떤 객체를 리턴하는데
2. 이 객체의 then 메소드로, '리스폰스가 왔을 때 실행할 콜백'을 등록할 수 있다.
3. 이렇게 등록된 콜백들은 then 메소드로 등록한 순서대로 실행되고, 이때 이전 콜백의 리턴값을 이후 콜백이 넘겨받아서 사용할 수 있다.

# url 이란?

일반 사람들도 '인터넷 주소' 정도로 인식하고 있을 만큼 익숙하다. URL은 Uniform Resource Locator의 약자이다. 굳이 우리말로 번역하자면 '규격화된 리소스 검색자' 정도가 되겠다.
쉽게 말해서 웹에 존재하는 특정 데이터를 나타내는 문자열이다.

url의 구성을 살펴보자.
`https://www.codeitshopping.com/men/shirts?color=blue&size=l`
위와 같은 url이 있다고 하면,

1. `www.codeitshopping.com`: 이 부분은 **Host(호스트)**라고 하며, 전 세계 모든 서버 중 하나의 서버를 특정한다.
2. `/men/shirts`: **Path(경로)**라고 하며, 서버에 있는 데이터 중 원하는 데이터를 특정한다.
3. `?color=blue&size=l`: **Query(쿼리)**라고 하며, 데이터에 관한 세부적인 요구사항을 말한다. 항상 존재하지는 않는다. `=`을 사이에 두고 키와 값으로 이루어져 있으며, `&`로 여러개의 속성을 나눌 수 있다.

# 도메인 네임

특정 서버를 가리키는 `host` 부분에는 우리가 아는 naver.com 혹은 google.com이 들어가지만, 사실 IP 주소를 넣어도 동작한다. 왜냐하면 사실 naver.com 과 같은 문자열은 사실 IP 주소를 가리키고 있기 때문이다.  
사실 naver.com 같은 것을 도메인 네임(Domain Name)이라고 한다. 도메인 네임은 Domain Name System이라고 하는 체계를 바탕으로 생성되는 문자열 이름으로, 인터넷 세계에 존재하는 수많은 영역을 추상적으로 나타내기 위해 사용되는 개념이다.

하나의 도메인 네임은 여러 개의 도메인으로 구성된다. 그리고 더 상위의 도메인일수록 도메인 네임 중에서 오른쪽에 있다. 코드잇 사이트의 주소인 codeit.kr 도메인 네임을 예로 들어보자.

도메인에는 최상단에 루트 도메인(root domain)이라는 것이 있다. 이 루트 도메인은 그냥 인터넷 전체를 나타내는 단위라고 생각하면 되는데, 루트 도메인은 사실 그냥 '빈 문자열'로 나타내고 우리가 도메인 네임을 입력할 때도 표시하지 않는 경우가 많다. 만약 도메인 네임에서 루트 도메인까지 나타내려면 도메인 네임의 오른쪽 끝에 점을 하나 더 찍어주면 된다. 그러니까 codeit.kr도 codeit.kr.로 바꾸어 쓰면 루트 도메인까지 나타낸 이론적으로 더욱 완벽한 도메인 네임이 된다. 실제로 브라우저에서 어떤 도메인 네임이든 이렇게 맨 끝에 점을 하나 더 쓰고 엔터를 쳐도 잘 접속이 된다.

루트 도메인 뱌로 하위에는 Top-Level Domain이라는 것이 있다. 도메인 네임 끝에서 일반적으로 볼 수 있는 .kr, .net, .gov 등이 그것이다. Top-Level Domain은 사이트가 속한 국가 또는 사이트가 제공하는 서비스의 카테고리를 나타낸다.

그리고 각각의 Top-level Domain 하위에는 Second-Level Domain이 있다. codeit.kr에서는 codeit이 Second-Level Domain이다.

그리고 여기서 한 단계씩 더 내려가서 www.codeit.kr의 www(Third-Level 도메인), test.www.codeit.kr의 test(Fourth-Level 도메인)까지 쭉 도메인이 생겨날 수 있다. 하지만 실제 서비스에서는 보통 Third-Level 도메인 정도까지만 사용하는 경우가 많다.

## Domain Name Resolution의 원리

도메인 네임이 뭔지 배웠으니, 이제 codeit.kr 같은 도메인 네임만으로 어떻게 특정 서버와 통신할 수 있는지 알아보자. 우리가 브라우저에서 도메인 네임만으로도 특정 컴퓨터와 통신할 수 있는 것은 본격적인 통신을 시작하기 전에 도메인 네임을 IP 주소로 변환해주는 절차가 존재하기 때문이다.

우리가 브라우저에 codeit.kr 이라고 쓰고 엔터를 치면 가장 먼저 어떤 일이 발생하는지, 이미지와 함께 순서대로 살펴보자.

![Domain Name Resolution의 원리](/assets//images/domain-name-resolution.png)

1. 내 컴퓨터는 기본적으로 설정된 네임 서버(Name Server)에 codeit.kr 의 IP 주소를 알려달라는 요청을 보낸다. 네임 서버라는 건 도메인 네임을 IP 주소로 변환하는 과정에 참여하는 서버들이다. 내 컴퓨터에서 맨 처음 어떤 네임 서버에 요청할 것인지는 미리 설정되어 있고, 기존의 설정에서 다른 네임 서버로 바꾸는 것도 가능하다. 내 컴퓨터가 사용하는 네임 서버에 관한 설정은 OS마다 다르다.
2. 컴퓨터의 요청을 받은 네임 서버는 이제 루트 네임 서버(Root Name Server)에 '.kr'로 끝나는 도메인 네임들을 관리하는 네임 서버의 주소를 알려달라는 요청을 보낸다.
3. 그럼 루트 네임 서버는 '.kr' 네임 서버의 IP 주소를 알려준다.
4. 그럼 네임 서버는 '.kr' 네임 서버에게 'codeit.kr'의 IP 주소를 알려줄 수 있는, 'codeit.kr' 네임 서버의 IP 주소를 알려달라고 요청한다.
5. 그럼 '.kr' 네임 서버는 'codeit.kr' 네임 서버의 IP 주소를 알려준다.
6. 그럼 네임 서버는 'codeit.kr' 네임 서버에게 'codeit.kr'의 IP 주소를 알려달라고 요청한다.
7. 마침내, 네임 서버는 'codeit.kr'의 실제 IP 주소를 응답으로 얻게 된다.
8. 네임 서버는 제 컴퓨터에게 codeit.kr의 IP 주소를 알려주고, 내 컴퓨터는 이 IP 주소를 갖고 코드잇 서버와 본격적인 통신을 시작한다.

참고로, 한 컴퓨터에서 codeit.kr에 접속할 때마다 매번 1부터 8까지의 단계가 항상 발생하는 것은 아니다. 왜냐하면 이미 한번 codeit.kr의 IP 주소를 받은 후에는 컴퓨터의 OS가 그 IP 주소를 보통 별도로 저장해두고 계속 사용하기 때문이다. 이뿐만 아니라 내 컴퓨터가 사용하는 가장 근처의 네임 서버 또한 자주 요청받는 도메인 네임에 대해서는 별도로 외부에 요청할 필요가 없도록 캐시(cache)로 관리하는 경우가 많다.

# 그 이후

1. 어떤 서버와 통신해야 하는지를 식별하고 나면, 웹 브라우저는 해당 서버로 리퀘스트를 보낸다. 이때 URL에서 path 이후의 부분들(path와 query)을 리퀘스트에 담아서 보낸다.
2. 리퀘스트를 받은 서버는 리퀘스트에 담긴 path 이후의 부분들을 보고, 그것이 의미하는 데이터를 찾고, 찾은 결과를 리스폰스에 담아서 보내준다.
3. 그럼 웹 브라우저는 받은 리스폰스의 내용을 갖고 사용자에게 보여준다.

# http란?

위에서 건너뛴 `https`는 무엇일까? 이 부분은 URL에서는 **Scheme(스킴)** 이라고 하며 프로토콜의 이름이 들어간다.

## 프로토콜?

통신을 하는 두 주체가 지켜야 하는 통신 규약. 쉽게 우리의 상황에 대입하자면 브라우저와 웹 서버가 통신을 할 때 지켜야 하는 약속 같은 것이다. 위에 있는 `https`가 바로 브라우저와 웹 서버가 통신할 때 지켜야 하는 프로토콜의 이름이다.  
URL에 프로토콜 명이 있다는 것은 그 뒷부분에 있는 서버의 리소스를 가져오기 위해 통신을 할 때 해당 프로토콜을 지키겠다는 약속이다. 웹 브라우저도, 웹 서버도 해당 프로토콜에 맞게 요청과 응답을 보내야 한다.

`http`란 HyperText Transfer protocol의 줄임말로, 말 그대로 HyperText를 전송하는 프로토콜이란 뜻이다. HyperText란 다른 텍스트에 대한 참조를 갖고 있는 텍스트다. 원래 `http`는 HyperText를 브라우저와 서버 사이에서 주고받기 위해 탄생한 프로토콜이기에 이런 이름을 갖고 있다. 물론 지금에 와서는 음성, 영상등 많은 리로스를 http 프로토콜로 주고 받고 있다.  
이제는 `http`에 보안성이 더해진 `https`를 주로 쓴다. 안전한 `http`쯤 되겠다.

# JSON 데이터를 객체로 변환하기

자바스크립트에는 JSON 데이터를 다루기 위한 기본 객체인 `JSON`이 있다. 이 객체의 `parse`라는 메서드를 사용하면 string 타입의 JSON을 자바스크립트 객체로 변환할 수 있다.

```javascript
fetch("https://learn.codeit.kr/api/topics")
  .then((response) => response.text())
  .then((result) => {
    const topics = JSON.parse(result);
    console.log(topics);
  });
```

# 리퀘스트의 구성

- Head: Request에 대한 부가 정보(Method 등)
- Body: 실제 데이터를 담는 부분
