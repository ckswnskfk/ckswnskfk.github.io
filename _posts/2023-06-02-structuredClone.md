---
title: "[F-Lab 모각코 챌린지] 14일차"
excerpt: "structuredClone"
categories:
  - Javascript
tags:
  - f-lab
  - 에프랩
  - TIL
  - Javascript
  - Browser
  - Deep Copy
  - structuredClone
last_modified_at: 2023-06-02
toc: true
---

javascript의 참조 타입을 복사하고자 할 때, 대부분의 경우 깊은 복사를 하기 원할 것이다. 하지만 막상 깊은 복사를 구현하기는 까다로운 탓에 많은 경우 외부 라이브러리에서 제공하는 깊은 복사 함수를 쓰곤 했다. 하지만 이제는 많은 브라우저에서 structuredClone() 라는 글로벌 함수를 제공한다. 오늘은 얕은 복사와 깊은 복사, 그리고 주인공인 structuredClone()에 대해 알아보자.

# 원시 타입과 참조 타입

먼저 왜 얕은 복사와 깊은 복사란 개념이 있는지 부터 알아보자. 자바스크립트의 메모리 구조는 데이터와 식별자가 직접 연결 돼 있지 않다. 원시타입과 참조 타입 모두 그러하다. 데이터를 가리키는 메모리 주소와 식별자를 연결하는데, 원시 타입의 경우 그 주소에 바로 데이터가 저장 돼 있지만, 참조 타입의 경우엔 그 주소에 참조 타입의 프로퍼티들이 저장돼 있는 주소 영역이 저장 돼 있다. 그래서 원시 타입을 복사, 즉 아래와 같이 할당 하면

```javascript
const a = 10;
const b = a;
```

a 식별자에 연결된 주소에는 숫자 10이 저장 돼 있고, b 식별자에도 그 주소가 연결된다.

```javascript
console.log(a === b); // true
```

아니라고? 원시 타입은 값을 참조하지 않고 복사한다고? 그래 말 잘했다. 값을 수정하는 경우 어떻게 되는 지 알아보자.

```javascript
const a = 10;
let b = a;

b = 20;

console.log(a); // 10
console.log(b); // 20
```

것 보라고? 좀 더 들어봐라. 자바스크립트 메모리 내부적으로 어떻게 돌아가는지 살펴보자.

1. a 식별자에 10을 할당하려고 하면 데이터를 저장하는 메모리 영역에서 10을 저장한 곳이 있는지 찾는다. 있다면 그 주소를, 없다면 10을 저장하고 그 메모리의 주소를 식별자 a와 연결한다.
2. b 식별자와 a 식별자에 연결 된 주소를 연결한다.
3. b 식별자에 20을 재할당하려고 하면 마찬가지로 데이터를 저장하는 메모리 영역에서 20을 저장한 곳이 있는지 찾는다. 있다면 그 주소를, 없다면 20을 저장하고 그 메모리의 주소를 식별자 b와 연결한다.

어떤가? 이렇게 동작한다면 말이 되지 않는가? 잘 모르겠으면 코어 자바스크립트 책을 봐라. 결국 원시 타입이든 참조 타입이든 값을 할당한다는 것은 식별자와 메모리 주소를 연결하는 것이다.

그렇다면 참조 타입에서는 왜 얕은 복사와 깊은 복사란 개념이 있는 걸까? 말로 표현하자면 아주 간단하다. 메모리 주소로 찾아가는 과정을 한 번 더 거치기 때문이다. 코드로 살펴보자.

```javascript
const a = {
  b: 10,
  c: 20,
};

const d = a;

console.log(a); // {b: 10, c: 20}
console.log(d); // {b: 10, c: 20}
console.log(a === d); // true

d.b = "abc";

console.log(a); // {b: 'abc', c: 20}
console.log(d); // {b: 'abc', c: 20}
```

어떤 현상이 일어났나? 나는 d 식별자의 프로퍼티 b를 수정했는데 a의 프로퍼티 b도 바뀌어 버렸다. 위에서 설명한 식별자와 데이터가 어떻게 연결돼 있는지를 생각하면 간단하다. 식별자 a가 가리키는 주소로 간다. 그 곳엔 또 주소 영역이 있다. 우리는 식별자 d에 그 주소 영역을 연결한 것이다. 그래서 새로운 메모리 공간이 확보된 것이 아니라, 같은 메모리 공간을 참조하고 있는 것이다. a가 가리키는 곳과 d가 가리키는 곳이 같으니, a에서 접근해 바꾸나 d에서 접근해 바꾸나 같은 것이다. 집은 한 곳인데 평소랑 다른 길로 왔다고 다른 집이 돼 있길 기대하면 안되겠지.

여기까지가 얕은 복사가 일어나는 배경이 되는 메모리 구조 설명이다. 이제부터 본격적으로 복사에 대해 알아보자.

# 얕은 복사

지나가던 친구가 위와 같은 예제를 보고 잘난척을 하며 이렇게 하면 된다고 알려준다.

```javascript
const a = {
  b: 10,
  c: 20,
};

const d = {
  b: a.b,
  c: a.c,
};

console.log(a); // {b: 10, c: 20}
console.log(d); // {b: 10, c: 20}
console.log(a === d); // false

d.b = "abc";

console.log(a); // {b: 10, c: 20}
console.log(d); // {b: 'abc', c: 20}
```

와 개쩐다! 원본인 a는 바뀌지 않고 d만 바뀌었다!!! 이렇게 반응해주니 이런 것도 알려준다.

```javascript
const a = {
  b: 10,
  c: 20,
};

const d = { ...a };

console.log(a); // {b: 10, c: 20}
console.log(d); // {b: 10, c: 20}
console.log(a === d); // false

d.b = "abc";

console.log(a); // {b: 10, c: 20}
console.log(d); // {b: 'abc', c: 20}
```

와!!! 쩜쩜쩜 뭐야 이런 게 있어?! 친구는 득의양양하며 집에 간다. 이제 여러분은 신나서 이것 저것 해보기 시작한다.

```javascript
const a = {
  num: 10,
  obj: {
    str: "abc",
  },
};

const d = { ...a };

console.log(a === d); // false

d.obj.str = "def";

console.log(a); // {num: 10, obj: {str: 'def'}}
console.log(d); // {num: 10, obj: {str: 'def'}}
```

뭔가 또 잘 못 됐다. 나는 d의 obj의 str을 바꿨는데 왜 a도 바뀌지...? a === d도 false인데!

여러분은 이제야 얕은 복사를 경험한 것이다. 왜 이런 현상이 일어났는지는 위에 설명한 메모리 저장 동작을 이 경우에 대입해 천천히 생각해 보면 된다. 모르겠으면 코어 자바스크립트 책 봐라.

이제 객체 안의 객체, 혹은 배열, 혹은 다른 참조 타입까지 복사해 새로운 메모리 공간에 저장하는 깊은 복사에 대해 알아보자.

# 깊은 복사

깊은 복사는 얕은 복사의 반대 되는 개념으로, 말 그대로 참조 타입 내부의 참조 타입까지 복사 하는 것이다.

깊은 복사 하면 나오는 몇 가지 대표적인 방법이 있다. 첫 번째는 외부 라이브러리인 lodash의 cloneDeep(). 두 번째는 JSON 객체를 이용해 객체를 문자열로 바꿨다가 다시 객체 형태로 바꾸는 방법, 세 번째는 직접 깊은 복사 함수를 작성하는 것이다. 첫 번째는 외부 라이브러리 전체를 받아야 한다는 점에서, 두 번째는 지원하지 않는 타입도 많은데다 비교적 느린 점, 세 번째는 작성하기도 까다로울뿐더러 신경써서 작성하지 않으면 안쓰느니만 못할 수도 있다는 단점이 있다. 그래도 편의성과 안정성 모두를 만족하는 방법이 lodash를 쓰는 방법이라 실제로 많은 곳에서 사용할 것이다.

이제 이 방법들을 사용하지 않고도 손 쉽게 깊은 복사를 할 수 있는 오늘의 주인공, structuredClone()에 대해 알아보자.

# structuredClone

HTML5 명세에 The structured clone 알고리즘이 정의되었다. 이 알고리즘은 대상 객체의 필드가 객체라면 모든 속성이 새 객체로 복제될 때 까지 재귀적으로 동작한다. 그러니까 깊은 복사를 한다는 거다. 정규 표현식, RegExp(정규 표현식) 객체, Blob 객체, File 객체, ImageData 객체도 복사할 수 있다. 이게 다 뭔지는 모르겠다... 여튼 복사가 잘 된댄다. 복사하지 않는 것도 있는데, Error와 Function 객체, DOM node를 복사하려고 하면 exception을 throw 한다고 한다. setters와 getters도 복사되지 않는다. 프로토타입 체인도 복사되지 않는다.

이제 어떻게 사용하는 지 알아보자.

```javascript
const myDeepCopy = structuredClone(myOriginal);
```

이렇게 쓰기만 하면 된다. 뭘 깔 필요도 없고, 브라우저에서 동작하는 자바스크립트라면 그냥 이게 다다! 정말 좋아 이거 정말 좋아

객체의 크기가 큰 경우 structuredClone()가 아주 빠르고, 오버헤드가 일어날 일도 없다고 한다. 그래서 기본적으로 깊은 복사를 하려면 structuredClone()을 사용하라고!

\*참고: <https://web.dev/structured-clone/>,
<https://chaewonkong.github.io/posts/js-deep-copy.html>,
<https://developer.mozilla.org/ko/docs/Web/API/Web_Workers_API/Structured_clone_algorithm>,
코어 자바스크립트(서적)
